<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Puff Run - Dream Edition Super Advanced</title>
<style>
  * {
    margin: 0; padding: 0; box-sizing: border-box;
  }
  html, body {
    width: 100%; height: 100%; overflow: hidden;
    background: radial-gradient(circle at center, #000, #111);
    font-family: 'Rubik', sans-serif;
    color: white;
  }
  canvas {
    display: block;
    background: radial-gradient(circle at center, #111, #000);
    width: 100vw;
    height: 100vh;
    touch-action: none;
  }
  #score-display, #level-message, #high-score-display, #message-box {
    position: absolute;
    z-index: 11;
    font-weight: 700;
    user-select: none;
    pointer-events: none;
  }
  #score-display {
    top: 10px; left: 20px; font-size: 1.6rem; text-align: left;
  }
  #high-score-display {
    top: 40px; left: 20px; font-size: 1rem; opacity: 0.7;
  }
  #level-message {
    top: 80px; width: 100%; font-size: 2rem; text-align: center; opacity: 0;
    transition: opacity 0.7s ease;
  }
  #message-box {
    top: 110px; width: 100%; font-size: 1.4rem; text-align: center; opacity: 0;
    transition: opacity 0.5s ease;
  }
  #toggle-sound, #toggle-pause {
    position: absolute; top: 10px; z-index: 11;
    font-size: 1.7rem;
    background: none; border: none; color: white; cursor: pointer; user-select: none;
    transition: transform 0.2s ease;
  }
  #toggle-sound:hover, #toggle-pause:hover {
    transform: scale(1.2);
  }
  #toggle-sound { right: 60px; }
  #toggle-pause { right: 20px; }
  #start-screen, #game-over-screen, #continue-screen, #skin-store {
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.9);
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    font-size: 2.3rem; z-index: 20;
    user-select: none;
  }
  #continue-screen div, #game-over-screen div, #start-screen div {
    margin-bottom: 25px;
  }
  #skin-list {
    display: flex; flex-wrap: wrap; justify-content: center; gap: 14px;
    max-width: 90vw; margin-bottom: 20px;
  }
  #skin-list button {
    width: 90px; height: 90px; border-radius: 50%; border: none;
    font-weight: 700; cursor: pointer; color: white; font-size: 0.9rem;
    display: flex; flex-direction: column; justify-content: center; align-items: center;
    white-space: pre-line;
    transition: transform 0.3s ease, box-shadow 0.3s ease;
    position: relative;
  }
  #skin-list button:hover:not([disabled]) {
    transform: scale(1.15);
    box-shadow: 0 0 15px 3px rgba(125, 60, 255, 0.7);
    z-index: 1;
  }
  #skin-list button[disabled] {
    filter: grayscale(1) brightness(0.6);
    cursor: default;
  }
  #skin-list button .price-tag {
    position: absolute;
    bottom: 6px;
    background: rgba(0,0,0,0.6);
    padding: 2px 6px;
    border-radius: 8px;
    font-size: 0.7rem;
  }
  button {
    padding: 14px 28px; font-size: 1.3rem; border: none; border-radius: 10px;
    background: #6a0dad; color: white; cursor: pointer; margin-top: 15px;
    transition: background 0.3s;
  }
  button:hover:not([disabled]) {
    background: #7d3cff;
  }
  button[disabled] {
    background: #444 !important;
    cursor: default;
  }
</style>
<link href="https://fonts.googleapis.com/css2?family=Rubik:wght@700&display=swap" rel="stylesheet" />
</head>
<body>

<canvas id="game-canvas"></canvas>
<div id="score-display">Score: 0</div>
<div id="high-score-display"></div>
<div id="level-message"></div>
<div id="message-box"></div>
<button id="toggle-sound" title="Toggle Sound">üîä</button>
<button id="toggle-pause" title="Pause/Resume">‚è∏Ô∏è</button>

<div id="start-screen">
  <div>Welcome to Puff Run - Dream Edition</div>
  <button id="play-btn">Start Game</button>
  <button id="store-btn">üé® Skins</button>
  <div style="font-size: 1rem; margin-top: 30px; opacity: 0.7;">Use Arrow keys or A/D to move</div>
</div>

<div id="game-over-screen" style="display:none;">
  <div id="score-display-final"></div>
  <button id="retry-btn">Play Again</button>
</div>

<div id="continue-screen" style="display:none;">
  <div>You hit an obstacle! Watch an ad to continue?</div>
  <button id="watch-ad-btn">Watch Ad</button>
  <button id="no-thanks-btn">No Thanks</button>
</div>

<div id="skin-store" style="display:none;">
  <h2>Select Your Dreamy Skin</h2>
  <div id="skin-list"></div>
  <button id="close-skin-store-btn">Close</button>
</div>

<!-- Audio -->
<audio id="bg-music" loop preload="auto" src="long-file.mp3"></audio>
<audio id="hit-sound" preload="auto" src="short-file.mp3"></audio>
<audio id="powerup-sound" preload="auto" src="powerup.mp3"></audio>

<script>
(() => {
  // Grab DOM elements
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');

  const bgMusic = document.getElementById('bg-music');
  const hitSound = document.getElementById('hit-sound');
  const powerupSound = document.getElementById('powerup-sound');

  const soundToggle = document.getElementById('toggle-sound');
  const pauseToggle = document.getElementById('toggle-pause');

  const levelMessage = document.getElementById('level-message');
  const messageBox = document.getElementById('message-box');

  const startScreen = document.getElementById('start-screen');
  const gameOverScreen = document.getElementById('game-over-screen');
  const scoreDisplay = document.getElementById('score-display');
  const highScoreDisplay = document.getElementById('high-score-display');
  const finalScoreDisplay = document.getElementById('score-display-final');

  const continueScreen = document.getElementById('continue-screen');
  const watchAdBtn = document.getElementById('watch-ad-btn');
  const noThanksBtn = document.getElementById('no-thanks-btn');

  const skinStore = document.getElementById('skin-store');
  const skinList = document.getElementById('skin-list');
  const storeBtn = document.getElementById('store-btn');
  const closeSkinStoreBtn = document.getElementById('close-skin-store-btn');

  let width, height;
  let soundOn = true;
  let paused = false;
  let gameActive = false;
  let score = 0;
  let highScore = 0;
  let currentLevel = 1;
  let obstacles = [];
  let stars = [];
  let particles = [];
  let player = null; // Declare here
  let continueAvailable = false;
  let adPlaying = false;
  let powerups = [];
  let powerupActive = null;
  let powerupTimer = 0;

  // Skins data
  const skins = [
    { id: 'default', name: 'Default', colors: ['#0af', '#005'], price: 0, unlocked: true },
    { id: 'dream1', name: 'Aurora Glow', colors: ['#ff5f6d', '#ffc371'], price: 1, unlocked: false },
    { id: 'dream2', name: 'Neon Pulse', colors: ['#0ff', '#0a0'], price: 3, unlocked: false },
    { id: 'dream3', name: 'Star Glimmer', colors: ['#ffcc00', '#ff00cc'], price: 5, unlocked: false },
    { id: 'dream4', name: 'Ocean Pearl', colors: ['#0ff', '#004'], price: 8, unlocked: false },
    { id: 'dream5', name: 'Cosmic Light', colors: ['#9900ff', '#00ffcc'], price: 13, unlocked: false },
    { id: 'dream6', name: 'Dream Dust', colors: ['#f9d423', '#ff4e50'], price: 17, unlocked: false },
    { id: 'dream7', name: 'Celestial Nova', colors: ['#3a1c71', '#d76d77', '#ffaf7b'], price: 20, unlocked: false },
  ];

  let selectedSkin = skins[0]; // default skin

  // Load saved data
  function loadGameData() {
    try {
      const savedSkinId = localStorage.getItem('puffrun-skin');
      if(savedSkinId) {
        const savedSkin = skins.find(s => s.id === savedSkinId);
        if(savedSkin) selectedSkin = savedSkin;
      }
      const savedHighScore = localStorage.getItem('puffrun-highscore');
      if(savedHighScore) highScore = parseInt(savedHighScore);
      const savedUnlocks = localStorage.getItem('puffrun-unlocks');
      if(savedUnlocks) {
        const unlockIds = JSON.parse(savedUnlocks);
        skins.forEach(skin => {
          if(unlockIds.includes(skin.id)) skin.unlocked = true;
        });
      }
    } catch(e) {
      // ignore errors
    }
  }

  function saveGameData() {
    try {
      localStorage.setItem('puffrun-skin', selectedSkin.id);
      localStorage.setItem('puffrun-highscore', highScore);
      const unlockedSkins = skins.filter(s => s.unlocked).map(s => s.id);
      localStorage.setItem('puffrun-unlocks', JSON.stringify(unlockedSkins));
    } catch(e) {}
  }

  // Resize canvas & create stars
  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    if(player) {
      player.y = height - player.radius - 50;
      player.x = Math.min(player.x, width - player.radius);
    }

    stars = [];
    for(let i=0; i<180; i++) {
      stars.push({
        x: Math.random() * width,
        y: Math.random() * height,
        radius: Math.random() * 1.5,
        speed: 0.2 + Math.random() * 1.5
      });
    }
  }

  // Create player object
  function createPlayer() {
    player = {
      x: width/2,
      y: height - 75,
      radius: 26,
      velocityX: 0,
      acceleration: 1.1,
      maxSpeed: 10 + currentLevel * 0.3,
      friction: 0.85,
      colors: selectedSkin.colors,
      shield: false,
      shieldAlpha: 0,
      movingLeft: false,
      movingRight: false
    };
  }

  // Particles on collision
  function createParticles(x, y, color) {
    for(let i=0; i<25; i++) {
      particles.push({
        x, y,
        radius: Math.random() * 4 + 2,
        color,
        velocityX: (Math.random() - 0.5) * 7,
        velocityY: (Math.random() - 0.5) * 7,
        life: 50 + Math.random()*30
      });
    }
  }

  // Draw player
  function drawPlayer() {
    const gradient = ctx.createRadialGradient(
      player.x,
      player.y,
      player.radius / 3,
      player.x,
      player.y,
      player.radius
    );
    if (player.colors.length === 3) {
      gradient.addColorStop(0, player.colors[0]);
      gradient.addColorStop(0.5, player.colors[1]);
      gradient.addColorStop(1, player.colors[2]);
    } else {
      gradient.addColorStop(0, player.colors[0]);
      gradient.addColorStop(1, player.colors[1]);
    }

    ctx.fillStyle = gradient;
    ctx.shadowColor = player.colors[player.colors.length - 1];
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(player.x, player.y, player.radius, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;

    if(player.shield) {
      ctx.strokeStyle = `rgba(135,206,235,${player.shieldAlpha.toFixed(2)})`;
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius + 8, 0, Math.PI*2);
      ctx.stroke();

      // Animate shield alpha
      player.shieldAlpha += 0.04;
      if(player.shieldAlpha > 1) player.shieldAlpha = 0;
    }
  }

  function drawBackground() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = '#fff';
    stars.forEach(star => {
      ctx.beginPath();
      ctx.arc(star.x, star.y, star.radius, 0, Math.PI*2);
      ctx.fill();
      star.y += star.speed;
      if(star.y > height) {
        star.y = 0;
        star.x = Math.random() * width;
      }
    });
  }

  // draw obstacles
  function drawObstacles() {
    obstacles.forEach(ob => {
      ctx.fillStyle = ob.color;
      ctx.beginPath();
      if(ob.shape === 'circle') {
        ctx.arc(ob.x + ob.radius, ob.y + ob.radius, ob.radius, 0, Math.PI*2);
        ctx.fill();
      } else if(ob.shape === 'triangle') {
        ctx.moveTo(ob.x + ob.width/2, ob.y);
        ctx.lineTo(ob.x, ob.y + ob.height);
        ctx.lineTo(ob.x + ob.width, ob.y + ob.height);
        ctx.closePath();
        ctx.fill();
      } else { // rectangle
        ctx.fillRect(ob.x, ob.y, ob.width, ob.height);
      }
    });
  }

  // spawn obstacles
  function spawnObstacle() {
    const shapes = ['rect', 'circle', 'triangle'];
    const shape = shapes[Math.floor(Math.random() * shapes.length)];
    let ob;
    if(shape === 'circle') {
      const radius = 20 + Math.random() * 15;
      ob = {
        shape: 'circle',
        x: Math.random() * (width - radius*2),
        y: -radius*2 - 10,
        radius: radius,
        speed: getSpeedForLevel(),
        color: `hsl(${Math.random()*360}, 70%, 60%)`
      };
    } else if(shape === 'triangle') {
      const widthOb = 40 + Math.random()*20;
      const heightOb = widthOb * 0.8;
      ob = {
        shape: 'triangle',
        x: Math.random()*(width - widthOb),
        y: -heightOb - 10,
        width: widthOb,
        height: heightOb,
        speed: getSpeedForLevel(),
        color: `hsl(${Math.random()*360}, 80%, 50%)`
      };
    } else {
      const widthOb = 40 + Math.random()*40;
      const heightOb = 20 + Math.random()*15;
      ob = {
        shape: 'rect',
        x: Math.random()*(width - widthOb),
        y: -heightOb - 10,
        width: widthOb,
        height: heightOb,
        speed: getSpeedForLevel(),
        color: `hsl(${Math.random()*360}, 90%, 40%)`
      };
    }
    obstacles.push(ob);
  }

  // spawn powerups
  function spawnPowerup() {
    const types = ['shield', 'slow'];
    const type = types[Math.floor(Math.random() * types.length)];
    powerups.push({
      type,
      x: Math.random() * (width - 40) + 20,
      y: -40,
      radius: 20,
      speed: 3 + currentLevel * 0.4,
      color: type === 'shield' ? '#87ceeb' : '#ffcc00'
    });
  }

  function drawPowerups() {
    powerups.forEach(pu => {
      ctx.fillStyle = pu.color;
      ctx.beginPath();
      ctx.arc(pu.x, pu.y, pu.radius, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.font = 'bold 18px Rubik';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(pu.type === 'shield' ? 'üõ°' : 'üê¢', pu.x, pu.y);
    });
  }

  function updateLevel() {
    const newLevel = Math.floor(score / 1000) + 1;
    if(newLevel !== currentLevel) {
      currentLevel = newLevel;
      showLevelMessage(`Level ${currentLevel}`);
      if(player) player.maxSpeed = 10 + currentLevel * 0.3;
    }
  }

  function showLevelMessage(text) {
    levelMessage.textContent = text;
    levelMessage.style.opacity = 1;
    setTimeout(() => {
      levelMessage.style.opacity = 0;
    }, 2500);
  }

  function showMessage(text, duration = 2500) {
    messageBox.textContent = text;
    messageBox.style.opacity = 1;
    setTimeout(() => {
      messageBox.style.opacity = 0;
    }, duration);
  }

  function getSpeedForLevel() {
    return 6 + currentLevel * 0.9;
  }

  // collision helpers
  function circleRectCollision(cx, cy, radius, rx, ry, rw, rh) {
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) < (radius*radius);
  }

  function circleCircleCollision(x1, y1, r1, x2, y2, r2) {
    const dx = x1 - x2;
    const dy = y1 - y2;
    return (dx*dx + dy*dy) <= (r1 + r2)*(r1 + r2);
  }

  function circleTriangleCollision(cx, cy, r, tx, ty, tw, th) {
    // Approximate collision: bounding box check
    if(cx + r < tx || cx - r > tx + tw || cy + r < ty || cy - r > ty + th) return false;
    // Approximate by distance to center of bounding box
    const cxRel = cx - (tx + tw/2);
    const cyRel = cy - (ty + th/2);
    return (cxRel*cxRel + cyRel*cyRel) < (r + Math.min(tw, th)/2) ** 2;
  }

  // main game loop
  function update() {
    if(!gameActive || paused || adPlaying) return;

    ctx.clearRect(0, 0, width, height);
    drawBackground();

    // spawn obstacles randomly
    if(Math.random() < 0.012 + currentLevel * 0.005) spawnObstacle();

    // spawn powerups
    if(Math.random() < 0.0015) spawnPowerup();

    // move obstacles down
    obstacles.forEach(ob => { ob.y += ob.speed; });
    obstacles = obstacles.filter(ob => ob.y < height + 50);

    // move powerups down
    powerups.forEach(pu => { pu.y += pu.speed; });
    powerups = powerups.filter(pu => pu.y < height + 50);

    // move player
    if(player.movingLeft) player.velocityX -= player.acceleration;
    if(player.movingRight) player.velocityX += player.acceleration;

    player.velocityX *= player.friction;
    if(Math.abs(player.velocityX) < 0.1) player.velocityX = 0;
    if(player.velocityX > player.maxSpeed) player.velocityX = player.maxSpeed;
    if(player.velocityX < -player.maxSpeed) player.velocityX = -player.maxSpeed;

    player.x += player.velocityX;

    // keep inside bounds
    if(player.x < player.radius) { player.x = player.radius; player.velocityX = 0; }
    if(player.x > width - player.radius) { player.x = width - player.radius; player.velocityX = 0; }

    drawPlayer();

    // check collision with obstacles
    for(const ob of obstacles) {
      let collision = false;
      if(ob.shape === 'rect') {
        collision = circleRectCollision(player.x, player.y, player.radius, ob.x, ob.y, ob.width, ob.height);
      } else if(ob.shape === 'circle') {
        collision = circleCircleCollision(player.x, player.y, player.radius, ob.x + ob.radius, ob.y + ob.radius, ob.radius);
      } else if(ob.shape === 'triangle') {
        collision = circleTriangleCollision(player.x, player.y, player.radius, ob.x, ob.y, ob.width, ob.height);
      }
      if(collision) {
        if(player.shield) {
          createParticles(player.x, player.y, 'cyan');
          player.shield = false;
          showMessage('Shield Absorbed Hit!');
          obstacles.splice(obstacles.indexOf(ob),1);
          if(soundOn) powerupSound.play().catch(() => {});
        } else {
          if(soundOn) {
            hitSound.currentTime = 0;
            hitSound.play().catch(() => {});
          }
          gameActive = false;
          continueAvailable = true;
          document.getElementById('continue-screen').style.display='flex';
          return;
        }
      }
    }

    // collision with powerups
    for(let i=powerups.length-1; i>=0; i--) {
      const pu = powerups[i];
      if(circleCircleCollision(player.x, player.y, player.radius, pu.x, pu.y, pu.radius)) {
        powerupActive = pu.type;
        powerupTimer = pu.type === 'shield' ? 700 : 500;
        if(soundOn) powerupSound.play().catch(() => {});
        powerups.splice(i,1);
        if(pu.type === 'shield') {
          player.shield = true;
          player.shieldAlpha = 0;
        }
        showMessage(pu.type === 'shield' ? 'Shield Activated!' : 'Slow Motion Activated!');
      }
    }

    // slow motion
    if(powerupActive === 'slow') {
      obstacles.forEach(ob => ob.y -= 1.5);
      powerups.forEach(pu => pu.y -= 1.5);
    }

    // countdown powerup
    if(powerupTimer > 0) {
      powerupTimer--;
      if(powerupTimer === 0) {
        powerupActive = null;
        if(player) player.shield = false;
        showMessage('Power-up Ended');
      }
    }

    drawPlayer();
    drawObstacles();
    drawPowerups();

    // particles
    particles.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.radius, 0, Math.PI*2);
      ctx.fill();
      p.x += p.velocityX;
      p.y += p.velocityY;
      p.radius *= 0.95;
      p.life--;
    });
    particles = particles.filter(p => p.life > 0 && p.radius > 0.3);

    score++;
    document.getElementById('score-display').textContent = `Score: ${score}`;
    if(score > highScore) {
      highScore = score;
      document.getElementById('high-score-display').textContent = `High Score: ${highScore}`;
    }

    updateLevel();

    requestAnimationFrame(update);
  }

  function startGame() {
    score = 0;
    currentLevel = 1;
    obstacles = [];
    powerups = [];
    particles = [];
    createPlayer();
    gameActive = true;
    paused = false;
    continueAvailable = false;
    adPlaying = false;
    powerupActive = null;
    powerupTimer = 0;

    document.getElementById('start-screen').style.display='none';
    document.getElementById('game-over-screen').style.display='none';
    document.getElementById('continue-screen').style.display='none';
    if(soundOn) {
      bgMusic.volume = 0.4;
      bgMusic.play().catch(() => {});
    }
    highScore = Math.max(highScore, score);
    highScoreDisplay.textContent = `High Score: ${highScore}`;
    requestAnimationFrame(update);
  }

  function endGame() {
    gameActive = false;
    document.getElementById('score-display-final').textContent = `Score: ${score}`;
    document.getElementById('game-over-screen').style.display='flex';
    bgMusic.pause();
    saveGameData();
  }

  // Event listeners
  window.addEventListener('keydown', e => {
    if(!player || !gameActive) return;
    if(e.key==='ArrowLeft' || e.key==='a') player.movingLeft=true;
    if(e.key==='ArrowRight' || e.key==='d') player.movingRight=true;
  });
  window.addEventListener('keyup', e => {
    if(!player || !gameActive) return;
    if(e.key==='ArrowLeft' || e.key==='a') player.movingLeft=false;
    if(e.key==='ArrowRight' || e.key==='d') player.movingRight=false;
  });

  document.getElementById('play-btn').onclick = () => {
    startGame();
  };
  document.getElementById('retry-btn').onclick = () => {
    startGame();
  };

  document.getElementById('toggle-sound').onclick = () => {
    soundOn = !soundOn;
    document.getElementById('toggle-sound').textContent = soundOn ? 'üîä' : 'üîá';
    if(soundOn && gameActive && !paused) {
      bgMusic.play().catch(() => {});
    } else {
      bgMusic.pause();
    }
  };

  document.getElementById('toggle-pause').onclick = () => {
    if(!gameActive) return;
    paused=!paused;
    document.getElementById('toggle-pause').textContent= paused ? '‚ñ∂Ô∏è':'‚è∏Ô∏è';
    if(paused) bgMusic.pause();
    else {
      if(soundOn) bgMusic.play().catch(() => {});
      requestAnimationFrame(update);
    }
  };

  document.getElementById('watch-ad-btn').onclick = () => {
    if(adPlaying) return;
    adPlaying=true;
    document.getElementById('watch-ad-btn').disabled=true;
    document.getElementById('watch-ad-btn').textContent='Loading Ad...';

    let secondsLeft=5;
    const interval = setInterval(() => {
      document.getElementById('watch-ad-btn').textContent= `Ad ends in ${secondsLeft--}s`;
      if(secondsLeft<0) {
        clearInterval(interval);
        document.getElementById('continue-screen').style.display='none';
        createPlayer();
        gameActive=true;
        paused=false;
        adPlaying=false;
        document.getElementById('watch-ad-btn').disabled=false;
        document.getElementById('watch-ad-btn').textContent='Watch Ad';
        if(soundOn) bgMusic.play().catch(() => {});
        requestAnimationFrame(update);
      }
    }, 1000);
  };

  document.getElementById('no-thanks-btn').onclick= () => {
    document.getElementById('continue-screen').style.display='none';
    endGame();
  };

  document.getElementById('store-btn').onclick = () => {
    renderSkinStore();
    document.getElementById('skin-store').style.display='flex';
    document.getElementById('start-screen').style.display='none';
  };

  document.getElementById('close-skin-store-btn').onclick= () => {
    document.getElementById('skin-store').style.display='none';
    document.getElementById('start-screen').style.display='flex';
  };

  // Render skins in store
  function renderSkinStore() {
    skinList.innerHTML='';
    skins.forEach(skin => {
      const btn = document.createElement('button');
      if(skin.colors.length===3) {
        btn.style.background= `radial-gradient(circle at center, ${skin.colors.join(',')})`;
      } else {
        btn.style.background= `linear-gradient(135deg, ${skin.colors[0]}, ${skin.colors[1]})`;
      }
      btn.innerHTML= `${skin.name}<br><span class="price-tag">${skin.unlocked ? '‚úîÔ∏è Owned' : `$${skin.price}`}</span>`;
      if(!skin.unlocked && skin.price>0) {
        btn.onclick= ()=> {
          if(confirm(`Buy ${skin.name} for $${skin.price}?`)) {
            skin.unlocked=true;
            selectedSkin=skin;
            saveGameData();
            renderSkinStore();
            showMessage(`Purchased ${skin.name}`);
          }
        };
      } else {
        btn.onclick= ()=> {
          selectedSkin=skin;
          document.getElementById('skin-store').style.display='none';
          document.getElementById('start-screen').style.display='flex';
          saveGameData();
        };
      }
      skinList.appendChild(btn);
    });
  }

  // Initialize game
  loadGameData();
  resize();
  createPlayer();
  highScoreDisplay.textContent=`High Score: ${highScore}`;
  requestAnimationFrame(update);
})();
</script>
</body>
</html>
